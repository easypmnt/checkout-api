// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: payment.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (external_id, currency, amount, destination, status, message, memo, expires_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, external_id, currency, amount, destination, status, message, memo, expires_at, created_at, updated_at
`

type CreatePaymentParams struct {
	ExternalID  sql.NullString `json:"external_id"`
	Currency    string         `json:"currency"`
	Amount      int64          `json:"amount"`
	Destination string         `json:"destination"`
	Status      PaymentStatus  `json:"status"`
	Message     sql.NullString `json:"message"`
	Memo        sql.NullString `json:"memo"`
	ExpiresAt   sql.NullTime   `json:"expires_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.queryRow(ctx, q.createPaymentStmt, createPayment,
		arg.ExternalID,
		arg.Currency,
		arg.Amount,
		arg.Destination,
		arg.Status,
		arg.Message,
		arg.Memo,
		arg.ExpiresAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Currency,
		&i.Amount,
		&i.Destination,
		&i.Status,
		&i.Message,
		&i.Memo,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPaymentDestination = `-- name: CreatePaymentDestination :one
INSERT INTO payment_destinations (payment_id, destination, amount)
VALUES ($1, $2, $3)
RETURNING payment_id, destination, amount
`

type CreatePaymentDestinationParams struct {
	PaymentID   uuid.UUID `json:"payment_id"`
	Destination string    `json:"destination"`
	Amount      int64     `json:"amount"`
}

func (q *Queries) CreatePaymentDestination(ctx context.Context, arg CreatePaymentDestinationParams) (PaymentDestination, error) {
	row := q.queryRow(ctx, q.createPaymentDestinationStmt, createPaymentDestination, arg.PaymentID, arg.Destination, arg.Amount)
	var i PaymentDestination
	err := row.Scan(&i.PaymentID, &i.Destination, &i.Amount)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, external_id, currency, amount, destination, status, message, memo, expires_at, created_at, updated_at FROM payments WHERE id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id uuid.UUID) (Payment, error) {
	row := q.queryRow(ctx, q.getPaymentStmt, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Currency,
		&i.Amount,
		&i.Destination,
		&i.Status,
		&i.Message,
		&i.Memo,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByExternalID = `-- name: GetPaymentByExternalID :one
SELECT id, external_id, currency, amount, destination, status, message, memo, expires_at, created_at, updated_at FROM payments WHERE external_id = $1
`

func (q *Queries) GetPaymentByExternalID(ctx context.Context, externalID sql.NullString) (Payment, error) {
	row := q.queryRow(ctx, q.getPaymentByExternalIDStmt, getPaymentByExternalID, externalID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Currency,
		&i.Amount,
		&i.Destination,
		&i.Status,
		&i.Message,
		&i.Memo,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentDestinations = `-- name: GetPaymentDestinations :many
SELECT payment_id, destination, amount FROM payment_destinations WHERE payment_id = $1
`

func (q *Queries) GetPaymentDestinations(ctx context.Context, paymentID uuid.UUID) ([]PaymentDestination, error) {
	rows, err := q.query(ctx, q.getPaymentDestinationsStmt, getPaymentDestinations, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentDestination
	for rows.Next() {
		var i PaymentDestination
		if err := rows.Scan(&i.PaymentID, &i.Destination, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments SET status = $1 WHERE id = $2 RETURNING id, external_id, currency, amount, destination, status, message, memo, expires_at, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	Status PaymentStatus `json:"status"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.queryRow(ctx, q.updatePaymentStatusStmt, updatePaymentStatus, arg.Status, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Currency,
		&i.Amount,
		&i.Destination,
		&i.Status,
		&i.Message,
		&i.Memo,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
